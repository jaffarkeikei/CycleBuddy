#![no_std]
use soroban_sdk::{contract, contractimpl, contracttype, Address, BytesN, Env, Map, String, Symbol, Vec};

/// Health Insight types
#[derive(Clone)]
#[contracttype]
pub enum InsightType {
    Informational,
    Advisory,
    Alert,
}

/// Health Insight generated by AI
#[derive(Clone)]
#[contracttype]
pub struct HealthInsight {
    id: BytesN<32>,
    user: Address,
    insight_type: InsightType,
    title: String,
    description: String,
    recommendations: Vec<String>,
    confidence: u32,  // 0-100
    timestamp: u64,
    verified: bool,
    related_data_types: Vec<String>,
}

/// AI model metadata
#[derive(Clone)]
#[contracttype]
pub struct AIModel {
    id: BytesN<32>,
    name: String,
    version: String,
    description: String,
    data_types: Vec<String>,
    turret_id: String,
    created_at: u64,
    last_updated: u64,
    active: bool,
}

/// Turret configuration
#[derive(Clone)]
#[contracttype]
pub struct TurretConfig {
    id: String,
    url: String,
    public_key: String,
    authorized: bool,
}

/// Contract state
#[contract]
pub struct AIHealthInsightsContract {
    owner: Address,
    models: Map<BytesN<32>, AIModel>,
    turrets: Map<String, TurretConfig>,
    user_insights: Map<Address, Vec<BytesN<32>>>,
    insights: Map<BytesN<32>, HealthInsight>,
    user_permissions: Map<Address, Map<String, bool>>,
}

#[contractimpl]
impl AIHealthInsightsContract {
    /// Initialize contract
    pub fn initialize(env: Env, owner: Address) -> Self {
        owner.require_auth();
        
        Self {
            owner,
            models: Map::new(&env),
            turrets: Map::new(&env),
            user_insights: Map::new(&env),
            insights: Map::new(&env),
            user_permissions: Map::new(&env),
        }
    }
    
    /// Register a new AI model
    pub fn register_model(
        env: Env,
        name: String,
        version: String,
        description: String,
        data_types: Vec<String>,
        turret_id: String,
    ) -> BytesN<32> {
        // Only owner can register models
        self.owner.require_auth();
        
        // Check if turret exists
        if !self.turrets.contains_key(turret_id.clone()) {
            panic!("Turret not registered");
        }
        
        // Create model ID using hash of name and version
        let model_id_preimage = env.crypto().sha256(
            &String::from_str(&env, &format!("{}_{}", name.to_string(), version.to_string()))
        );
        
        // Create model
        let model = AIModel {
            id: model_id_preimage.clone(),
            name,
            version,
            description,
            data_types,
            turret_id,
            created_at: env.ledger().timestamp(),
            last_updated: env.ledger().timestamp(),
            active: true,
        };
        
        // Store model
        self.models.set(model_id_preimage.clone(), model);
        
        model_id_preimage
    }
    
    /// Register a turret for secure computation
    pub fn register_turret(
        env: Env,
        id: String,
        url: String,
        public_key: String,
    ) -> bool {
        // Only owner can register turrets
        self.owner.require_auth();
        
        // Create turret config
        let config = TurretConfig {
            id: id.clone(),
            url,
            public_key,
            authorized: true,
        };
        
        // Store config
        self.turrets.set(id, config);
        
        true
    }
    
    /// Generate health insights for a user
    pub fn generate_insights(
        env: Env,
        user: Address,
        data_types: Vec<String>,
        model_id: BytesN<32>,
    ) -> Vec<BytesN<32>> {
        // Require user authorization
        user.require_auth();
        
        // Check user permissions
        let permissions = self.user_permissions.get(user.clone()).unwrap_or(Map::new(&env));
        
        // Check if model exists
        let model = match self.models.get(model_id.clone()) {
            Some(m) => m,
            None => panic!("Model not found"),
        };
        
        // Check if model is active
        if !model.active {
            panic!("Model is not active");
        }
        
        // Get turret config
        let turret = match self.turrets.get(model.turret_id.clone()) {
            Some(t) => t,
            None => panic!("Turret not found"),
        };
        
        // In a real implementation, this would make a call to the Stellar Turret
        // For this prototype, we'll generate simulated insights
        
        let mut insight_ids = Vec::new(&env);
        
        // Simulated insights for demo purposes
        // In a real implementation, these would come from the Turret's ML processing
        
        // Simple insight
        let insight_id_1 = env.crypto().sha256(
            &String::from_str(&env, &format!("{}_insight_1_{}", user.to_string(), env.ledger().timestamp()))
        );
        
        let insight_1 = HealthInsight {
            id: insight_id_1.clone(),
            user: user.clone(),
            insight_type: InsightType::Informational,
            title: String::from_str(&env, "Cycle Regularity Improving"),
            description: String::from_str(&env, "Your cycle has shown improved regularity over the past 3 months."),
            recommendations: vec![&env, String::from_str(&env, "Continue your current lifestyle habits.")],
            confidence: 85,
            timestamp: env.ledger().timestamp(),
            verified: false,
            related_data_types: vec![&env, String::from_str(&env, "cycle_length")],
        };
        
        // Store insight
        self.insights.set(insight_id_1.clone(), insight_1);
        insight_ids.push_back(insight_id_1);
        
        // Another simulated insight
        let insight_id_2 = env.crypto().sha256(
            &String::from_str(&env, &format!("{}_insight_2_{}", user.to_string(), env.ledger().timestamp()))
        );
        
        let insight_2 = HealthInsight {
            id: insight_id_2.clone(),
            user: user.clone(),
            insight_type: InsightType::Advisory,
            title: String::from_str(&env, "Potential Symptom Pattern"),
            description: String::from_str(&env, "We've detected a pattern between certain foods and increased cramps."),
            recommendations: vec![
                &env, 
                String::from_str(&env, "Consider tracking your diet more closely."),
                String::from_str(&env, "Discuss with healthcare provider if pattern continues."),
            ],
            confidence: 70,
            timestamp: env.ledger().timestamp(),
            verified: false,
            related_data_types: vec![&env, String::from_str(&env, "symptoms"), String::from_str(&env, "diet")],
        };
        
        // Store insight
        self.insights.set(insight_id_2.clone(), insight_2);
        insight_ids.push_back(insight_id_2);
        
        // Update user insights
        let mut user_insight_ids = self.user_insights.get(user.clone()).unwrap_or(Vec::new(&env));
        for id in insight_ids.iter() {
            user_insight_ids.push_back(id);
        }
        self.user_insights.set(user, user_insight_ids);
        
        insight_ids
    }
    
    /// Get user's health insights
    pub fn get_user_insights(env: Env, user: Address) -> Vec<HealthInsight> {
        // Require user authorization
        user.require_auth();
        
        let mut insights_list = Vec::new(&env);
        
        // Get user insight IDs
        if let Some(insight_ids) = self.user_insights.get(user) {
            for id in insight_ids.iter() {
                if let Some(insight) = self.insights.get(id) {
                    insights_list.push_back(insight);
                }
            }
        }
        
        insights_list
    }
    
    /// Mark an insight as verified (by healthcare professional)
    pub fn verify_insight(env: Env, user: Address, insight_id: BytesN<32>, verifier: Address) -> bool {
        // Require both user and verifier authorization
        user.require_auth();
        verifier.require_auth();
        
        // Get the insight
        let mut insight = match self.insights.get(insight_id.clone()) {
            Some(i) => i,
            None => panic!("Insight not found"),
        };
        
        // Check that this insight belongs to the user
        if insight.user != user {
            panic!("Insight does not belong to this user");
        }
        
        // Update verification status
        insight.verified = true;
        
        // Save updated insight
        self.insights.set(insight_id, insight);
        
        true
    }
    
    /// Update user permissions for data types
    pub fn update_user_permissions(
        env: Env,
        user: Address,
        data_type: String,
        allowed: bool,
    ) -> bool {
        // Require user authorization
        user.require_auth();
        
        // Get current permissions
        let mut permissions = self.user_permissions.get(user.clone()).unwrap_or(Map::new(&env));
        
        // Update permission
        permissions.set(data_type, allowed);
        
        // Save updated permissions
        self.user_permissions.set(user, permissions);
        
        true
    }
    
    /// Get available AI models
    pub fn get_models(env: Env) -> Vec<AIModel> {
        let mut models_list = Vec::new(&env);
        
        for (_, model) in self.models.iter() {
            if model.active {
                models_list.push_back(model);
            }
        }
        
        models_list
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::{testutils::Address as _, vec, Env};

    #[test]
    fn test_initialize() {
        let env = Env::default();
        let owner = Address::random(&env);
        let contract = AIHealthInsightsContract::initialize(env.clone(), owner.clone());
        
        // Check that contract is initialized correctly
        assert_eq!(contract.owner, owner);
    }
} 